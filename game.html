<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<script type="text/javascript">
/* TODO: Make everything IE compatible */

var TILE_SIZE = 100;
var GRID_SIZE = 5;

var TILE_BG_COL = 'rgb(255, 255, 255)';
var TILE_HIGHLIGHT_COL = 'rgb(220, 220, 220)';
var TILE_TEXT_COL = 'rgb(60, 60, 60)';

var inPath = false;
var currentPath = [];
var grid;
var ctx;

class Tile {
	// cx and cy store the coordinates of the center of the tile.
	constructor(cx, cy, val) {
		this.cx = cx;
		this.cy = cy;
		this.val = val;
		this.highlight = false;

		// Used to store the distance to move downward during a translation
		// animation.
		this.drop = 0;

		// Used to store the tile size during a vanish animation.
		this.tileSize = TILE_SIZE;
		this.showText = true;
	}

	render(ctx) {
		ctx.fillStyle = this.highlight ? TILE_HIGHLIGHT_COL : TILE_BG_COL;
		ctx.fillRect(this.cx - this.tileSize / 2, this.cy - this.tileSize /
			2,
			this.tileSize, this.tileSize);
		if (this.showText) {
			ctx.font = '20px sans-serif';
			ctx.fillStyle = TILE_TEXT_COL;
			ctx.fillText(this.val, this.cx - 10, this.cy);
		}
	}

}

class TileGrid {
	constructor(x, y) {
		this.grid = new Array(GRID_SIZE);
		this.x = x;
		this.y = y;
		for (let i = 0; i < GRID_SIZE; i++) {
			this.grid[i] = new Array(GRID_SIZE);
		}

		// The grid is stored in column major format for now in order to
		// maintain equivalence: x, y <=> col, row.
		for (let col = 0; col < GRID_SIZE; col++) {
			for (let row = 0; row < GRID_SIZE; row++) {
				this.grid[col][row] = new Tile(
					x + col * TILE_SIZE + TILE_SIZE / 2,
					y + row * TILE_SIZE + TILE_SIZE / 2,
					getRandomIntInclusive(-9, 9));
			}
		}
	}

	render(ctx) {
		ctx.fillStyle = 'rgb(255, 255, 255)';
		ctx.fillRect(0, 0, 500, 500);
		ctx.strokeStyle = 'rgb(100, 100, 100)';
		for (let col = 0; col < GRID_SIZE; col++) {
			for (let row = 0; row < GRID_SIZE; row++) {
				this.grid[col][row].render(ctx);
			}
		}
	}

	// (x, y) must be relative to the grid and not to the window.
	getTileForPoint(x, y) {
		for (let col = 0; col < GRID_SIZE; col++) {
			for (let row = 0; row < GRID_SIZE; row++) {
				let t = this.grid[col][row];
				if (Math.abs(x - t.cx) <= t.tileSize / 2 && Math.abs(y - t
						.cy) <= t.tileSize / 2) {
					return {
						'col': col,
						'row': row
					};
				}
			}
		}
	}

	highlightTile(ctx, col, row) {
		this.grid[col][row].highlight = true;
		this.grid[col][row].render(ctx);
	}

	clearHighlights(ctx) {
		for (let col = 0; col < GRID_SIZE; col++) {
			for (let row = 0; row < GRID_SIZE; row++) {
				this.grid[col][row].highlight = false;
				this.grid[col][row].render(ctx);
			}
		}
	}
}

function getRandomIntInclusive(min, max) {
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getCurrentPathSum() {
	let sum_value_int = 0;
	for (const t of currentPath) {
		sum_value_int += grid.grid[t.col][t.row].val;
	}
	return sum_value_int;
}

function updateCurrentPathSumText() {
	let sum_value = document.getElementById("sum_value");
	if (currentPath.length > 0) {
		sum_value.textContent = getCurrentPathSum();
	} else {
		// Treat an empty path as having no sum as opposed to a "zero" sum
		sum_value.textContent = "";
	}
}

// Only adds the |coords| to the path if they haven't been added before and are
// adjacent to an existing tile in the path.
function maybeAddToPath(coords) {
	if (!coords) {
		return false;
	}
	for (const t of currentPath) {
		if (t.row === coords.row && t.col === coords.col) {
			return false;
		}
	}

	if (currentPath.length === 0) {
		currentPath.push(coords);
		updateCurrentPathSumText();
		return true;
	} else {
		for (const t of currentPath) {
			if ((t.row === coords.row && t.col === coords.col + 1) ||
				(t.row === coords.row && t.col === coords.col - 1) ||
				(t.row - 1 === coords.row && t.col === coords.col) ||
				(t.row + 1 === coords.row && t.col === coords.col)) {
				currentPath.push(coords);
				updateCurrentPathSumText();
				return true;
			}
		}
	}
	return false;
}

function vanishFrame() {
	// ================================================================
	// 1. First we vanish all the highlighted tiles with a "collapse"
	// animation.
	// ================================================================
	let allVanishesDone = true;
	for (const coord of currentPath) {
		if (grid.grid[coord.col][coord.row].tileSize > 0) {
			allVanishesDone = false;
			grid.grid[coord.col][coord.row].showText = false;
			// 10 is a divisor of the tile size so |tileSize| will evenly
			// reach zero eventually.
			grid.grid[coord.col][coord.row].tileSize -= 10;
		} else {
			grid.grid[coord.col][coord.row] = undefined;
		}
	}
	if (!allVanishesDone) {
		grid.render(ctx);
		requestAnimationFrame(vanishFrame);
	} else {
		currentPath = [];

		// =========================================================
		// 2. Second, we translate all the tiles that were affected
		// by the removal of the tiles in the first step, downwards.
		// =========================================================

		// Calculate how much each non-highlighted tile needs to move down
		// and store it in its |drop| attr.
		let newTilesPerCol = [];
		for (let col = 0; col < GRID_SIZE; col++) {
			newTilesPerCol.push(0);
			// Move from bottom to top keeping track of the number
			// of highlighted tiles seen so far. This will be the
			// number of spots each tile needs to move down.
			for (let row = GRID_SIZE - 1; row >= 0; row--) {
				if (grid.grid[col][row] === undefined) {
					newTilesPerCol[col]++;
				} else {
					let drop = newTilesPerCol[col];
					grid.grid[col][row].drop = drop * TILE_SIZE;
					// Reassign the current tile to its post
					// animation (col, row) in the grid.
					grid.grid[col][row + drop] = grid.grid[col][row];
				}
			}
		}
		// Create new tiles in the negative space above the canvas that will
		// drop down to make up for the vanishing tiles.
		for (let col = 0; col < GRID_SIZE; col++) {
			for (let negRow = 0; negRow < newTilesPerCol[col]; negRow++) {
				let t = new Tile(
					grid.x + col * TILE_SIZE + TILE_SIZE / 2,
					grid.y - (negRow + 1) * TILE_SIZE + TILE_SIZE / 2,
					getRandomIntInclusive(-9, 9));
				t.drop = newTilesPerCol[col] * TILE_SIZE;
				// Assign the new tile to its post animation
				// (col, row) in the grid.
				grid.grid[col][newTilesPerCol[col] - negRow - 1] = t;
			}
		}

		// Translation animation loop. Each tile t moves t.drop * TILE_SIZE
		// downwards.
		translateFrame();
	}
}

function translateFrame() {
	let allTranslatesDone = true;
	for (let col = 0; col < GRID_SIZE; col++) {
		for (let row = 0; row < GRID_SIZE; row++) {
			if (grid.grid[col][row].drop > 0) {
				allTranslatesDone = false;
				// 10 is always a divisor of the distance
				// any tile needs to move so |drop| will
				// evenly reach zero eventually.
				grid.grid[col][row].drop -= 10;
				grid.grid[col][row].cy += 10;
			}
		}
	}
	if (!allTranslatesDone) {
		grid.render(ctx);
		requestAnimationFrame(translateFrame);
	}
}

function draw() {
	let canvas = document.getElementById("tutorial");
	let rect = canvas.getBoundingClientRect();
	ctx = canvas.getContext("2d", {
		alpha: false
	});

	ctx.fillStyle = 'rgb(255, 255, 255)';
	ctx.fillRect(0, 0, 500, 500);

	grid = new TileGrid(0, 0);
	grid.render(ctx);

	canvas.addEventListener('mousedown', function(e) {
		if (!inPath) {
			inPath = true;
			let coords = grid.getTileForPoint(e.clientX - rect.left, e
				.clientY - rect.top);
			if (maybeAddToPath(coords)) {
				grid.highlightTile(ctx, coords.col, coords.row);
			}
		}
	});
	canvas.addEventListener('mousemove', function(e) {
		if (inPath) {
			let coords = grid.getTileForPoint(e.clientX - rect.left, e
				.clientY - rect.top);
			if (maybeAddToPath(coords)) {
				grid.highlightTile(ctx, coords.col, coords.row);
			}
		}
	});
	document.addEventListener('mouseup', function(e) {
		if (inPath) {
			inPath = false;
			if (getCurrentPathSum() === 0) {
				vanishFrame();
			} else {
				grid.clearHighlights(ctx);
				currentPath = [];
				updateCurrentPathSumText();
			}
		}
	});
}
</script>
</head>
<body onload="draw()">
<div id="sum_view">
	<span id="sum_label">&Sigma;</span>
	<span id="sum_value"></span>
</div>
<canvas id="tutorial" width="500" height="500" style="border: thin solid gray"></canvas>
</body>
</html>
